{
    "solution_id": "llama3.1-8b-3275",
    "problem_id": "p01822",
    "language": "Python",
    "solution": "```python\nimport sys\nimport math\nfrom collections import defaultdict\n\nclass Point:\n    def __init__(self, x, y, id):\n        self.x = x\n        self.y = y\n        self.id = id\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n    def __eq__(self, other):\n        return self.x == other.x and self.y == other.y\n\nclass Segment:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n    def __hash__(self):\n        return hash((self.p1, self.p2))\n\n    def __eq__(self, other):\n        return self.p1 == other.p1 and self.p2 == other.p2\n\nclass ConvexHullTrick:\n    def __init__(self, points):\n        self.points = points\n        self.hull = self.get_hull()\n\n    def get_hull(self):\n        def cross_product(p1, p2, p3):\n            return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n\n        def orientation(p1, p2, p3):\n            cp = cross_product(p1, p2, p3)\n            if cp == 0:\n                return 0\n            elif cp > 0:\n                return 1\n            else:\n                return -1\n\n        def convex_hull(points):\n            n = len(points)\n            if n < 3:\n                return points\n\n            hull = []\n            l = 0\n            for i in range(1, n):\n                if points[i].x < points[l].x:\n                    l = i\n\n            p = l\n            while True:\n                hull.append(points[p])\n                q = (p + 1) % n\n                for i in range(n):\n                    if orientation(points[p], points[q], points[i]) == -1:\n                        q = i\n                p = q\n                if p == l:\n                    break\n\n            return hull\n\n        points.sort(key=lambda p: (p.x, p.y))\n        hull = convex_hull(points)\n        return hull\n\n    def contains(self, point):\n        def orientation(p1, p2, p3):\n            cp = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n            if cp == 0:\n                return 0\n            elif cp > 0:\n                return 1\n            else:\n                return -1\n\n        def inside(p, q, r):\n            cp = orientation(p, q, r)\n            if cp == 0:\n                return False\n            elif cp == 1:\n                return True\n            else:\n                return False\n\n        def on_segment(p, q, r):\n            if (q.x <= max(p.x, r.x) and q.x >= min(p.x, r.x) and\n                    q.y <= max(p.y, r.y) and q.y >= min(p.y, r.y)):\n                return True\n            return False\n\n        def check(point, hull):\n            n = len(hull)\n            for i in range(n):\n                p = hull[i]\n                q = hull[(i + 1) % n]\n                if on_segment(point, p, q) or inside(point, p, q):\n                    return True\n            return False\n\n        return check(point, self.hull)\n\ndef main():\n    input = sys.stdin.readline\n    n, m, q = map(int, input().split())\n    points = [Point(*map(int, input().split()), i) for i in range(n)]\n    segments = [Segment(points[i-1], points[j-1]) for i, j in (map(int, input().split()) for _ in range(m))]\n    queries = [Point(*map(int, input().split()), i) for i in range(q)]\n\n    graph = defaultdict(list)\n    for segment in segments:\n        graph[segment.p1.id].append(segment)\n        graph[segment.p2.id].append(segment)\n\n    for point in points:\n        graph[point.id].sort(key=lambda s: (s.p1.id, s.p2.id))\n\n    for point in points:\n        point.graph = graph[point.id]\n\n    for query in queries:\n        query.graph = graph[query.id]\n\n    for query in queries:\n        if ConvexHullTrick(query.graph).contains(query):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()\n```",
    "model": "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
    "prompt": "You are a university student working on a programming assignment for a course. Your task is to provide the coding solution to a problem using the most appropriate programming language and practices for the given scenario. Your output should be only the code, without any explanations. Ensure the code is functional, correct for the specified language. Do not include any introductory text or output besides the code itself."
}