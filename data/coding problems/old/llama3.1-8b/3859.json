{
    "solution_id": "llama3.1-8b-3859",
    "problem_id": "p02285",
    "language": "Python",
    "solution": "```python\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if not self.root:\n            self.root = Node(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        if key < node.key:\n            if node.left:\n                self._insert(node.left, key)\n            else:\n                node.left = Node(key)\n        else:\n            if node.right:\n                self._insert(node.right, key)\n            else:\n                node.right = Node(key)\n\n    def find(self, key):\n        return self._find(self.root, key)\n\n    def _find(self, node, key):\n        if not node:\n            return False\n        if key == node.key:\n            return True\n        elif key < node.key:\n            return self._find(node.left, key)\n        else:\n            return self._find(node.right, key)\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        if not node:\n            return None\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if not node.left and not node.right:\n                return None\n            elif not node.left:\n                return node.right\n            elif not node.right:\n                return node.left\n            else:\n                min_node = self._find_min(node.right)\n                node.key = min_node.key\n                node.right = self._delete(node.right, min_node.key)\n        return node\n\n    def _find_min(self, node):\n        while node.left:\n            node = node.left\n        return node\n\n    def inorder(self):\n        result = []\n        self._inorder(self.root, result)\n        return result\n\n    def _inorder(self, node, result):\n        if node:\n            self._inorder(node.left, result)\n            result.append(node.key)\n            self._inorder(node.right, result)\n\n    def preorder(self):\n        result = []\n        self._preorder(self.root, result)\n        return result\n\n    def _preorder(self, node, result):\n        if node:\n            result.append(node.key)\n            self._preorder(node.left, result)\n            self._preorder(node.right, result)\n\n\ndef main():\n    bst = BinarySearchTree()\n    m = int(input())\n    for _ in range(m):\n        op = input().split()\n        if op[0] == 'insert':\n            bst.insert(int(op[1]))\n        elif op[0] == 'find':\n            print('yes' if bst.find(int(op[1])) else 'no')\n        elif op[0] == 'delete':\n            bst.delete(int(op[1]))\n        elif op[0] == 'print':\n            inorder = bst.inorder()\n            preorder = bst.preorder()\n            print(' '.join(map(str, inorder)))\n            print(' '.join(map(str, preorder)))\n\n\nif __name__ == '__main__':\n    main()\n```",
    "model": "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo",
    "prompt": "You are a university student working on a programming assignment for a course. Your task is to provide the coding solution to a problem using the most appropriate programming language and practices for the given scenario. Your output should be only the code, without any explanations. Ensure the code is functional, correct for the specified language. Do not include any introductory text or output besides the code itself."
}